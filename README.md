# pouchdb-entity-fabric
PouchDB abstraction layer modeled after .net's Entity Framework

```
npm install pouchdb-entity-fabric
```

PouchDB Entity Fabric is an abstraction layer that wraps [PouchDB](https://pouchdb.com/) and makes creating repeatable processes in PouchDB easier.  Often times using PouchDB, a repository layer needs to be created and adding new document types requires a new repository.  PouchDB Entity Fabric removes the need for these repository layers all together.  Let's get to the code:

## Installation
```
npm install pouchdb-entity-fabric
```

## Usage
To get started with PouchDB Entity Fabric, inherit from the base DataContext class

```typescript
import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    MyFirstDocument = "MyFirstDocument",
    MySecondDocument = "MySecondDocument"
}

interface IMyFirstEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
}

interface IMySecondEntity extends IDbRecord<DocumentTypes> {
    propertyThree: string;
    propertyFour: number;
}

export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    myFirstDbSet = this.createDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
    mySecondDbSetWithAutoIdGeneration = this.createDbSet<IMySecondEntity>(DocumentTypes.MySecondDocument);
}
```

## Entity Declaration
Entites can be declared a few different ways.  Two of the main ways are to create an interface and inherit from `IDbRecord<TDocumentType>` or add the properties from `IDbRecord<TDocumentType>` to your entity.

```typescript
interface IMyFirstEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
}

// OR

interface IMyFirstEntity {
    propertyOne: string;
    propertyTwo: string;
    readonly _id: string;
    readonly _rev: string;
    DocumentType: DocumentTypes;
}
```

## Creating a DbSet
The DbSet concept is derrived from .NET's entity framework and works the same way.  Items must be changed in the DbSet, once all changes are made, `saveChanges()` must be called on the context to persist all changes from the DbSet

To get started, declare your entities and document types like we did below.  Next, give your `DbSet<>` any name you wish.  Last, supply the correct parameters for `createDbSet()`

DbSets work in two different ways
- Automatic Id Generation
- User Created Id

```typescript
import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    MyFirstDocument = "MyFirstDocument",
    MySecondDocument = "MySecondDocument"
}

interface IMyFirstEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
}

interface IMySecondEntity extends IDbRecord<DocumentTypes> {
    propertyThree: string;
    propertyFour: number;
}

export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    // This will create a DbSet with a manually created id from DocumentType/propertyOne/propertyTwo
    myFirstDbSet = this.createDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");

    // This will create a DbSet with an automatically created id which is generated by PouchDB
    mySecondDbSetWithAutoIdGeneration = this.createDbSet<IMySecondEntity>(DocumentTypes.MySecondDocument);
}
```

## Adding Data
### With no id generation
```typescript
const context = new PouchDbDataContext();

const [myFirstItem] = context.myFirstDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// myFirstItem will have the _rev, _id, DocumentType properties added to the entity returned from add().  Those id's will be populated accordingly, _rev will always be populated after saveChanges() is called.  In this case the _id property will be set after add() is called
```

### With id generation
If no property id keys are provided to the db set, then we assume the id will be auto generated by PouchDB
```typescript
const context = new PouchDbDataContext();

const [mySecondItem] = await context.mySecondDbSetWithAutoIdGeneration.add({ propertyThree: "some value", propertyFour: 1 });

await context.saveChanges();

// mySecondItem will have the _rev, _id, DocumentType properties added to the entity returned from add().  Those id's will be populated accordingly, _rev will always be populated after saveChanges() is called.  In this case the _id property will be set after saveChanges() is called
```

### Add array of entities
```typescript
const context = new PouchDbDataContext();

const [first, second] = await context.mySecondDbSetWithAutoIdGeneration.add(
    { propertyThree: "some value", propertyFour: 1 }, 
    { propertyThree: "other value", propertyFour: 2 }
);

await context.saveChanges();

// OR

const context = new PouchDbDataContext();
const items = [
    { propertyThree: "some value", propertyFour: 1 }, 
    { propertyThree: "other value", propertyFour: 2 }
];

const [first, second] = await context.mySecondDbSetWithAutoIdGeneration.add(...items);

await context.saveChanges();

```

## Removing Data
### Remove One Entity
```typescript
context.myFirstDbSet.remove(someEntity);

await context.saveChanges();
```

### Remove array of entities
```typescript

const someEntities: IMyFirstEntity[] = []; // some array of items
context.myFirstDbSet.remove(...someEntities); // ensure we spread the array

await context.saveChanges();
```

## Modifying Data
Any entities returned by the context can be modified and saved by calling `saveChanges()`.  Entities are modified by reference, so there is no need to add or attach entities that are returned from the underlying context
```typescript
const context = new PouchDbDataContext();

const result = await context.myFirstDbSet.find(w => w.propertyOne === "some value");

result.propertyTwo = "some new updated value";

await context.saveChanges();

// result will now be saved to the underlying database after SaveChanges is called.  Entities are modified by reference, there is no need to attach or add an entity that is returned from the underlying context
```

## Default Property Values
With TypeScript/JavaScript, it can be hard to set default types unless a class is created and default types are set in the constructor.  This can get messy because extra syntax is required to create a class for each entity, instead of just an interface.  With an interface, they cannot have an initializer, meaning a default type cannot be set.  Also, when giving an Entity Type to a `DbSet<>`, optional properties will be optional throughout there usage, what if we want optional only on creation and set a default later?  To help with default property values, we can use property exclusion coupled with the `on()` event on a `DbSet<>`.  Below is an example of setting a sequence number to zero for every entity added, but not requiring the developer to set a sequence number when an item is being added and also maintaining the property as required (not optional).  

```typescript

import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    SomeDocument = "SomeDocument"
}

interface ISomeEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
    sequenceNumber: number;
}


export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db');

        // When an entity is added to the underlying context, automatically set the status to 'pending'
        // This is useful for setting default values when adding
        this.someDbSet.on("add", entity => {
            entity.sequenceNumber = 0;
        })
    }

    someDbSet = this.createDbSet<ISomeEntity, "sequenceNumber">(DocumentTypes.SomeDocument, "propertyOne", "propertyTwo");
}

const context = new PouchDbDataContext();

// notice status is not required here, it will be set by the on event later
const [ result ] = await context.someDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// result
{
    _id: "SomeDocument/some value/some value",
    _rev: "<generated>",
    DocumentType: "SomeDocument",
    sequenceNumber: 0,
    propertyOne: "some value",
    propertyTwo: "some value"
}
```

## Extending DbSet
A `DbSet<>` can be extended to override or add functionality to it
```typescript
enum DocumentTypes {
    Notes = "Notes",
    Contacts = "Contacts",
    Books = "Books"
}

interface ISomeDocument extends IDbRecord<TDocumentType> {
    propertyOne: string;
    propertyTwo: string;
}

interface IExtendedDbSet<TDocumentType extends string, TEntity extends IDbRecord<TDocumentType>, TExtraExclusions extends (keyof TEntity) | void = void> extends IDbSet<TDocumentType, TEntity, TExtraExclusions> {
    replaceAll(entities: OmittedEntity<TEntity, TExtraExclusions>[]): Promise<void>;
}

export class ExtendedDbSetContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    protected createExtendedDbSet<TEntity extends IBaseEntity, TExtraExclusions extends (keyof TEntity) | void = void>(documentType: DocumentTypes, ...idKeys: IdKeys<TEntity>) {
        const dbSet = this.createDbSet<TEntity, TExtraExclusions>(documentType, ...idKeys);
        const result: IExtendedDbSet<DocumentTypes, TEntity, TExtraExclusions> = dbSet as any;

        // extra db set methods here
        result.replaceAll = async (entities: TEntity[]) => {
            const items = await result.all();
            await result.removeRange(items);
            await result.addRange(entities);
            await this.saveChanges();
        }

        return result;
    }

    myExtendedDbSet = this.createExtendedDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
}
```

## Attaching/Detaching Entities
Attaching entities is useful for transferring entites from one context to another.  For example, if dev's want to pass an entity from one context to one or many child functions and do not want to pass the context with it.  We can pass the entity and create a new context, attach, and save changes.

Detaching entities is useful to make changes to the entity that will not be persisted to the underlying data store after saveChanges() is called.

### Attaching
```typescript

const someNewContext = new PouchDbDataContext();

someNewContext.myFirstDbSet.attach(someEntity); // NOTE: Ensure changes are made to the entity after its attached

someEntity.propertyOne = "some changed value"

await context.saveChanges(); // Changes will be persisted
```

### Detaching
```typescript
context.myFirstDbSet.detach(someEntity);

someEntity.propertyOne = "some changed value"

await context.saveChanges(); // No Changes will be peristed
```

## DbSet Events
DbSet's have two available event that can be subscribed to, `"add"`, `"remove"`.  
- `"add"` event is called after the entity is queued for addition.
- `"remove"` event is called after the entity is queued for removal.

## DataContext Events
The DataContext has three available events that can be subscribed to, `"entity-created"`, `"entity-updated"`, `"entity-removed"`.  
- `"entity-created"` event is called after the entity is created in the underlying data store.
- `"entity-updated"` event is called after the entity is updated in the underlying data store.
- `"entity-removed"` event is called after the entity is removed in the underlying data store.

## API
### DbSet Methods
| Method | Description |
| ----- | --- |
| `add(...entities: OmittedEntity<TEntity, TExtraExclusions>[]): Promise<Awaited<TEntity>[]>` | Add an entity or entities to the context and return it as a reference, save changes must be called to persist changes |
| `isMatch(first: TEntity, second: TEntity): boolean` | Checks for equality between two entities from the context.  This is useful to check and see if an entity belongs in the `DbSet` |
| `remove(...ids: string[]): Promise<void>` | Remove an entity or entities by id from the context, save changes must be called to persist changes |
| `remove(...entities: TEntity[]): Promise<void>` | Remove an entity or entities from the context, save changes must be called to persist changes |
| `empty(): Promise<void>` | Remove all entities from the DbSet, save changes must be called to persist changes |
| `all(): Promise<TEntity[]>` | Get all entities for the underlying document type |
| `get(...ids: string[]): Promise<TEntity[]>` | Find entity by an id or ids |
| `filter(selector: (entity: TEntity, index?: number, array?: TEntity[]) => boolean): Promise<TEntity[]>` | Filter entities for the underlying document type |
| `match(items: IDbRecordBase[]): TEntity[]` | Matches base entities and returns entities with matching document types.  This is useful for matching entites from `getAllDocs` in the data context, because those entites are generic and can belong to any `DbSet` |
| `find(selector: (entity: TEntity, index?: number, array?: TEntity[]) => boolean): Promise<TEntity \| undefined>` | Find an entity for the underlying document type |
| `detach(...entities: TEntity[]): void` | Detaches an entity from the data context.  This is useful for detaching and entity, modifying it and changes will not be persisted to PouchDB |
| `attach(...entites: TEntity[]): void` | Attaches an entity to the context |
| `first(): Promise<TEntity>` | Get first item in the DbSet |  
| `on(event: "add", callback: DbSetEventCallback<TDocumentType, TEntity>): void` | Called when an item is queued for creation in the underlying data context |
| `on(event: "remove", callback: DbSetEventCallback<TDocumentType, TEntity> \| DbSetIdOnlyEventCallback): void` | Called when an item is queued for removal in the underlying data context |

### DataContext Methods
| Method | Description |
| ----- | --- |
| `saveChanges(): Promise<number>` | Persist all changes to PouchDB, returns a count of all documents modified |
| `getAllDocs(): Promise<IDbRecordBase[]>` | Get all documents regardless of document type |
| `protected createDbSet<TEntity extends IDbRecord<TDocumentType>, TExtraExclusions extends (keyof TEntity) \| void = void>(documentType: TDocumentType, ...idKeys: EntityIdKeys<TDocumentType, TEntity>): IDbSet<TDocumentType, TEntity, TExtraExclusions>` | Method used to create a DbSet in the context.  NOTE: This is a protected method |
| `on(event: DataContextEvent, callback: DataContextEventCallback<TDocumentType>): void` | Subscribe to events on the data context |
| `hasPendingChanges(): boolean` | Check whether or not the context has any pending changes |
| `query<TEntity extends IDbRecord<TDocumentType>>(callback: (provider: PouchDB.Database) => Promise<TEntity[]>): Promise<TEntity[]>` | Invoke a query on PouchDB and return the result |
| `empty()` | Remove all entities from all DbSets in the data context, saveChanges must be called to persist these changes to the store |
| `destroyDatabase()` | Destroy Pouch Database |
| `optimize()` | Add optimizations to increase performance of PouchDB |

## Changes
### 1.1.0 -> 1.2.0 
- Added `empty()` to `DataContext<>`
- Added `destroyDatabase()` to `DataContext<>`
- Added `optimize()` to `DataContext<>`
- Added `get()` to `DbSet<>`
- Improved persistance performance:

|                          |     PouchDB (v1.1.0)      |      v1.1.0      |     PouchDB (v1.2.0)      | v1.2.0  |
| ------------------------ | ------------------------- | ---------------- | ------------------------- | ------- |
| `saveChanges` - 1 Entity |             N/A           | ~10ms            | ~10ms (bulk docs)         | ~10ms   |
| `saveChanges` - 50 Entities |          N/A           | ~850ms           | ~110ms (bulk docs)        | ~115ms  |
| `saveChanges` - 2000 Entities |          N/A         | ~30000ms         | ~8700ms (bulk docs)       | ~8800ms |


        
    
    

