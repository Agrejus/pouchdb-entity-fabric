# pouchdb-entity-fabric
PouchDB abstraction layer modeled after .net's Entity Framework

```
npm install pouchdb-entity-fabric
```

PouchDB Entity Fabric is an abstraction layer that wraps [PouchDB](https://pouchdb.com/) and makes creating repeatable processes in PouchDB easier.  Often times using PouchDB, a repository layer needs to be created and adding new document types requires a new repository.  PouchDB Entity Fabric removes the need for these repository layers all together.  Let's get to the code:

## Installation
```
npm install pouchdb-entity-fabric
```

## Usage
To get started with PouchDB Entity Fabric, inherit from the base DataContext class

```javascript
import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    MyFirstDocument = "MyFirstDocument",
    MySecondDocument = "MySecondDocument"
}

interface IMyFirstEntity {
    propertyOne: string;
    propertyTwo: string;
}

interface IMySecondEntity {
    propertyThree: string;
    propertyFour: number;
}

export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    myFirstDbSet = this.createDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
    mySecondDbSetWithAutoIdGeneration = this.createDbSet<IMySecondEntity>(DocumentTypes.MySecondDocument);
}
```

## Creating a DbSet
The DbSet concept is derrived from .NET's entity framework and works the same way.  Items must be changed in the DbSet, once all changes are made, `SaveChanges` must be called on the context to persist all changes from the DbSet

DbSets work in two different ways
- Automatic Id Generation
- User Created Id

## Adding Data
### With no id generation
```javascript
const context = new PouchDbDataContext();

const myFirstItem = { propertyOne: "some value", propertyTwo: "some value" };
context.myFirstDbSet.add(myFirstItem);

await context.saveChanges();

// myFirstItem will have the _rev property added after save changes is called
```

### With id generation
If no property id keys are provided to the db set, then we assume the id will be auto generated by PouchDB
```javascript
const context = new PouchDbDataContext();

const mySecondItem = { propertyThree: "some value", propertyFour: 1 };
context.mySecondDbSetWithAutoIdGeneration.add(mySecondItem);

await context.saveChanges();

// myFirstItem will have the _rev and _id property added after save changes is called
```

## Removing Data

```javascript
context.myFirstDbSet.remove(someEntity);

await context.saveChanges();
```

## Modifying Data
Any entities returned by the context can be modified and saved by calling `SaveChanges`.  Entities are modified by reference, so there is no need to add or attach entities that are returned from the underlying context
```javascript
const context = new PouchDbDataContext();

const result = await context.myFirstDbSet.find(w => w.propertyOne === "some value");

result.propertyTwo = "some new updated value";

await context.saveChanges();

// result will now be saved to the underlying database after SaveChanges is called.  Entities are modified by reference, there is no need to attach or add an entity that is returned from the underlying context
```

## API
### DbSet Methods
| Method | Description |
| ----- | --- |
| `add(entity: TEntity): Promise<void>` | Add an entity to the context, save changes must be called to persist changes |
| `addRange(entities: TEntity[]): Promise<void>` | Add list of entities to the context, save changes must be called to persist changes |
| `attach(entity: AttachedEntity<TEntity, TDocumentType, TEntityType>): Promise<void>` | Attaches an entity to the context |
| `remove(entity: TEntity) : Promise<void>` | Remove an entity from the context, save changes must be called to persist changes |
| `removeRange(entities: TEntity[]) : Promise<void>` | Remove entities from the context, save changes must be called to persist changes |
| `all(): Promise<(TEntityType & TEntity)[]>` | Get all entities for the underlying document type |
| `filter(selector: (entity: (TEntityType & TEntity), index?: number, array?: (TEntityType & TEntity)[]) => boolean): Promise<(TEntityType & TEntity)[]>` | Filter entities for the underlying document type |
| `find(selector: (entity: (TEntityType & TEntity), index?: number, array?: (TEntityType & TEntity)[]) => boolean) : Promise<(TEntityType & TEntity) \| undefined>` | Find an entity for the underlying document type |
| `onBeforeAdd(action: (entity: TEntity & TEntityType) => void): void` | Called before an entity is added to the data context |
| `isMatch(first: TEntity, second: TEntity): boolean` | Checks for equality between two entities from the context.  This is useful to check and see if an entity belongs in the `DbSet` |
| `detach(entities: TEntity[]): (TEntity & TEntityType)[]` | Detaches an entity from the data context.  This is useful for detaching and entity, modifying it and changes will not be persisted to PouchDB |
| `match(entities:IDbRecordBase[]): (TEntityType & TEntity)[]` | Matches base entities and returns entities with matching document types.  This is useful for matching entites from `getAllDocs` in the data context, because those entites are generic and can belong to any `DbSet` |

### DataContext Methods
| Method | Description |
| ----- | --- |
| `saveChanges(): Promise<number>` | Persist all changes to PouchDB, returns a count of all documents modified |
| `getAllDocs(): Promise<IDbRecordBase[]>` | Get all documents regardless of document type |
| `protected createDbSet<TEntity>(documentType: TDocumentType, ...idKeys: IdKeys<TEntity>): IDbSet<TDocumentType, Entity, IDbRecord<TDocumentType>>` | Method used to create a DbSet in the context.  NOTE: This is a protected method |





## Changes
### 1.0.0 -> 1.1.0 
- DbSet `add()` and `addRange()` method now return a refererence to added entity.  Can now be treated like a factory that creates the object
- Entities need to inherit from `IDbRecord<TDocumentType>` or have the following properties:
    - `readonly _id: string;`
    - `readonly _rev: string;`
    - `DocumentType: TDocumentType;`
- Removed `AttachedEntity<>`, using above mechanism instead.  This will eliminate the need to recast types after they are added to the context
- Added ability to exclude properties when using `add()` or `addRange()` methods on `DbSet<>`.  This allows users to exlucde properties and set them later.  Example:

```javascript

import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    SomeDocument = "SomeDocument"
}

interface ISomeEntity {
    propertyOne: string;
    propertyTwo: string;
    status: "pending" | "succeeded"
}


export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db');

        this.someDbSet.on("add", entity => {
            entity.status = "pending";
        })
    }

    someDbSet = this.createDbSet<ISomeEntity, "status">(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
}

const context = new PouchDbDataContext();

// notice status is not required here, it will be set by the on event later
const result = await context.someDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// result
{
    _id: "SomeDocument/some value/some value",
    _rev: "<generated>",
    DocumentType: "SomeDocument",
    status: "pending",
    propertyOne: "some value",
    propertyTwo: "some value"
}
```





        
    
    

