# pouchdb-entity-fabric
PouchDB abstraction layer modeled after .net's Entity Framework

```
npm install pouchdb-entity-fabric
```

PouchDB Entity Fabric is an abstraction layer that wraps [PouchDB](https://pouchdb.com/) and makes creating repeatable processes in PouchDB easier.  Often times using PouchDB, a repository layer needs to be created and adding new document types requires a new repository.  PouchDB Entity Fabric removes the need for these repository layers all together.  Let's get to the code:

## Installation
```
npm install pouchdb-entity-fabric
```

## Usage
To get started with PouchDB Entity Fabric, inherit from the base DataContext class

```typescript
import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    MyFirstDocument = "MyFirstDocument",
    MySecondDocument = "MySecondDocument"
}

interface IMyFirstEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
}

interface IMySecondEntity extends IDbRecord<DocumentTypes> {
    propertyThree: string;
    propertyFour: number;
}

export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    myFirstDbSet = this.createDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
    mySecondDbSetWithAutoIdGeneration = this.createDbSet<IMySecondEntity>(DocumentTypes.MySecondDocument);
}
```

## Entity Declaration
Entites can be declared a few different ways.  Two of the main ways are to create an interface and inherit from `IDbRecord<TDocumentType>` or add the properties from `IDbRecord<TDocumentType>` to your entity.

```typescript
interface IMyFirstEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
}

// OR

interface IMyFirstEntity {
    propertyOne: string;
    propertyTwo: string;
    readonly _id: string;
    readonly _rev: string;
    DocumentType: DocumentTypes;
}
```

## Creating a DbSet
The DbSet concept is derrived from .NET's entity framework and works the same way.  Items must be changed in the DbSet, once all changes are made, `saveChanges()` must be called on the context to persist all changes from the DbSet

DbSets work in two different ways
- Automatic Id Generation
- User Created Id

## Adding Data
### With no id generation
```typescript
const context = new PouchDbDataContext();

const [myFirstItem] = context.myFirstDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// myFirstItem will have the _rev property added after save changes is called
```

### With id generation
If no property id keys are provided to the db set, then we assume the id will be auto generated by PouchDB
```typescript
const context = new PouchDbDataContext();

const [mySecondItem] = await context.mySecondDbSetWithAutoIdGeneration.add({ propertyThree: "some value", propertyFour: 1 });

await context.saveChanges();

// mySecondItem will have the _rev and _id property added after save changes is called
```

### Add array of entities
```typescript
const context = new PouchDbDataContext();

const [first, second] = await context.mySecondDbSetWithAutoIdGeneration.add(
    { propertyThree: "some value", propertyFour: 1 }, 
    { propertyThree: "other value", propertyFour: 2 }
);

await context.saveChanges();

// OR

const context = new PouchDbDataContext();
const items = [
    { propertyThree: "some value", propertyFour: 1 }, 
    { propertyThree: "other value", propertyFour: 2 }
];

const [first, second] = await context.mySecondDbSetWithAutoIdGeneration.add(...items);

await context.saveChanges();

```

## Removing Data
### Remove One Entity
```typescript
context.myFirstDbSet.remove(someEntity);

await context.saveChanges();
```

### Remove array of entities
```typescript

const someEntities: IMyFirstEntity[] = []; // some array of items
context.myFirstDbSet.remove(...someEntities); // ensure we spread the array

await context.saveChanges();
```

## Modifying Data
Any entities returned by the context can be modified and saved by calling `saveChanges()`.  Entities are modified by reference, so there is no need to add or attach entities that are returned from the underlying context
```typescript
const context = new PouchDbDataContext();

const result = await context.myFirstDbSet.find(w => w.propertyOne === "some value");

result.propertyTwo = "some new updated value";

await context.saveChanges();

// result will now be saved to the underlying database after SaveChanges is called.  Entities are modified by reference, there is no need to attach or add an entity that is returned from the underlying context
```

## Default Property Values
With TypeScript/JavaScript, it can be hard to set default types unless a class is created and default types are set in the constructor.  This can get messy because extra syntax is required to create a class for each entity, instead of just an interface.  With an interface, they cannot have an initializer, meaning a default type cannot be set.  Also, when giving an Entity Type to a `DbSet<>`, optional properties will be optional throughout there usage, what if we want optional only on creation and set a default later?  To help with default property values, we can use property exclusion coupled with the `on()` event on a `DbSet<>`.  Below is an example of setting a sequence number to zero for every entity added, but not requiring the developer to set a sequence number when an item is being added and also maintaining the property as required (not optional).  

```typescript

import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    SomeDocument = "SomeDocument"
}

interface ISomeEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
    sequenceNumber: number;
}


export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db');

        // When an entity is added to the underlying context, automatically set the status to 'pending'
        // This is useful for setting default values when adding
        this.someDbSet.on("add", entity => {
            entity.sequenceNumber = 0;
        })
    }

    someDbSet = this.createDbSet<ISomeEntity, "sequenceNumber">(DocumentTypes.SomeDocument, "propertyOne", "propertyTwo");
}

const context = new PouchDbDataContext();

// notice status is not required here, it will be set by the on event later
const [ result ] = await context.someDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// result
{
    _id: "SomeDocument/some value/some value",
    _rev: "<generated>",
    DocumentType: "SomeDocument",
    sequenceNumber: 0,
    propertyOne: "some value",
    propertyTwo: "some value"
}
```

## Extending DbSet
A `DbSet<>` can be extended to override or add functionality to it
```typescript
enum DocumentTypes {
    Notes = "Notes",
    Contacts = "Contacts",
    Books = "Books"
}

interface ISomeDocument extends IDbRecord<TDocumentType> {
    propertyOne: string;
    propertyTwo: string;
}

interface IExtendedDbSet<TDocumentType extends string, TEntity extends IDbRecord<TDocumentType>, TExtraExclusions extends (keyof TEntity) | void = void> extends IDbSet<TDocumentType, TEntity, TExtraExclusions> {
    replaceAll(entities: OmittedEntity<TEntity, TExtraExclusions>[]): Promise<void>;
}

export class ExtendedDbSetContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db')
    }

    protected createExtendedDbSet<TEntity extends IBaseEntity, TExtraExclusions extends (keyof TEntity) | void = void>(documentType: DocumentTypes, ...idKeys: IdKeys<TEntity>) {
        const dbSet = this.createDbSet<TEntity, TExtraExclusions>(documentType, ...idKeys);
        const result: IExtendedDbSet<DocumentTypes, TEntity, TExtraExclusions> = dbSet as any;

        // extra db set methods here
        result.replaceAll = async (entities: TEntity[]) => {
            const items = await result.all();
            await result.removeRange(items);
            await result.addRange(entities);
            await this.saveChanges();
        }

        return result;
    }

    myExtendedDbSet = this.createExtendedDbSet<IMyFirstEntity>(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
}
```

## DbSet Events
DbSet's have two available event that can be subscribed to, `"add"`, `"remove"`.  
- `"add"` event is called after the entity is queued for addition.
- `"remove"` event is called after the entity is queued for removal.

## DataContext Events
The DataContext has three available events that can be subscribed to, `"entity-created"`, `"entity-updated"`, `"entity-removed"`.  
- `"entity-created"` event is called after the entity is created in the underlying data store.
- `"entity-updated"` event is called after the entity is updated in the underlying data store.
- `"entity-removed"` event is called after the entity is removed in the underlying data store.

## API
### DbSet Methods
| Method | Description |
| ----- | --- |
| `add(...entities: OmittedEntity<TEntity, TExtraExclusions>[]): Promise<Awaited<TEntity>[]>` | Add an entity or entities to the context and return it as a reference, save changes must be called to persist changes |
| `isMatch(first: TEntity, second: TEntity): boolean` | Checks for equality between two entities from the context.  This is useful to check and see if an entity belongs in the `DbSet` |
| `remove(...ids: string[]): Promise<void>` | Remove an entity or entities by id from the context, save changes must be called to persist changes |
| `remove(...entities: TEntity[]): Promise<void>` | Remove an entity or entities from the context, save changes must be called to persist changes |
| `empty(): Promise<void>;` | Remove all entities from the DbSet, save changes must be called to persist changes |
| `all(): Promise<TEntity[]>` | Get all entities for the underlying document type |
| `filter(selector: (entity: TEntity, index?: number, array?: TEntity[]) => boolean): Promise<TEntity[]>;` | Filter entities for the underlying document type |
| `match(items: IDbRecordBase[]): TEntity[]` | Matches base entities and returns entities with matching document types.  This is useful for matching entites from `getAllDocs` in the data context, because those entites are generic and can belong to any `DbSet` |
| `find(selector: (entity: TEntity, index?: number, array?: TEntity[]) => boolean): Promise<TEntity>` | Find an entity for the underlying document type |
| `detach(...entities: TEntity[]): TEntity[]` | Detaches an entity from the data context.  This is useful for detaching and entity, modifying it and changes will not be persisted to PouchDB |
| `attach(...entites: TEntity[]): void` | Attaches an entity to the context |
| `first(): Promise<TEntity>` | Get first item in the DbSet |  
| `on(event: "add", callback: DbSetEventCallback<TDocumentType, TEntity>): void` | Called when an item is queued for creation in the underlying data context |
| `on(event: "remove", callback: DbSetEventCallback<TDocumentType, TEntity> | DbSetIdOnlyEventCallback): void;` | Called when an item is queued for removal in the underlying data context |

### DataContext Methods
| Method | Description |
| ----- | --- |
| `saveChanges(): Promise<number>` | Persist all changes to PouchDB, returns a count of all documents modified |
| `getAllDocs(): Promise<IDbRecordBase[]>` | Get all documents regardless of document type |
| `protected createDbSet<TEntity extends IDbRecord<TDocumentType>, TExtraExclusions extends (keyof TEntity) | void = void>(documentType: TDocumentType, ...idKeys: IdKeys<TEntity>): IDbSet<TDocumentType, TEntity, TExtraExclusions>` | Method used to create a DbSet in the context.  NOTE: This is a protected method |
| `on(event: DataContextEvent, callback: DataContextEventCallback<TDocumentType>): void` | Subscribe to events on the data context |





## Changes
### 1.0.0 -> 1.1.0 
- DbSet `add()` and `addRange()` method now return a refererence to added entity.  Can now be treated like a factory that creates the object
- Entities need to inherit from `IDbRecord<TDocumentType>` or have the following properties:
    - `readonly _id: string;`
    - `readonly _rev: string;`
    - `DocumentType: TDocumentType;`
- Removed `AttachedEntity<>`, using above mechanism instead.  This will eliminate the need to recast types after they are added to the context
- Removed `onBeforeAdd()` method on `DbSet<>`
- Removed `removeRange()` method on `DbSet<>`.  Replaced by `remove()`
- Removed `addRange()` method on `DbSet<>`.  Replaced by `add()`
- Removed `removeAll()` method on `DbSet<>`.  Replaced by `empty()`
- Removed `removeRangeById()` method on `DbSet<>`.  Replaced by `remove()`
- Removed `removeById()` method on `DbSet<>`.  Replaced by `remove()`
- Added `on()` method to allow for adding events to the `DbSet<>`.  Event types: `"add"`, `"remove"`
- Added `on()` method to allow for adding events to the `DataContext<>`. Event Types: ``, ``, ``
- Added ability to exclude properties when using `add()` or `addRange()` methods on `DbSet<>`.  This allows users to exlucde properties and set them later, which is useful for creating default property values.  Example:
- Overloaded `remove()` and `add()` on `DbSet<>` to replace extra functions (above)
- Added `first(): Promise<TEntity>` method to get the first item in the `DbSet<>`.

```typescript

import { DataContext } from 'pouchdb-entity-fabric';

export enum DocumentTypes {
    SomeDocument = "SomeDocument"
}

interface ISomeEntity extends IDbRecord<DocumentTypes> {
    propertyOne: string;
    propertyTwo: string;
    status: "pending" | "succeeded"
}


export class PouchDbDataContext extends DataContext<DocumentTypes> {
    constructor() {
        super('some-db');

        // When an entity is added to the underlying context, automatically set the status to 'pending'
        // This is useful for setting default values when adding
        this.someDbSet.on("add", entity => {
            entity.status = "pending";
        })
    }

    someDbSet = this.createDbSet<ISomeEntity, "status">(DocumentTypes.MyFirstDocument, "propertyOne", "propertyTwo");
}

const context = new PouchDbDataContext();

// notice status is not required here, it will be set by the on event later
const [result] = await context.someDbSet.add({ propertyOne: "some value", propertyTwo: "some value" });

await context.saveChanges();

// result
{
    _id: "SomeDocument/some value/some value",
    _rev: "<generated>",
    DocumentType: "SomeDocument",
    status: "pending",
    propertyOne: "some value",
    propertyTwo: "some value"
}
```





        
    
    

